---
title: "GHSA Data Processing"
author: "Steph Eaneff\nTalus Analytics"
date: "8/9/2017"
output:
  html_document:
    toc: true
    toc_depth: 3
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r}
## do you want to save csvs when you run this Rmd file?
csv_flag <- TRUE
```

```{r, warning = FALSE, message = FALSE}
library(dplyr); library(plyr) ## restructure/aggregate data
library(reshape2) ## reshape data
library(DT) ## print pretty datatables
library(ggplot2) ## plotting
```

# Datasets (Initial Data)

## CRS

CRS data are not currently being used to generate the mock dataset, as the online CRS data exporter tool does not function as expected, and returns partial data plus an error message. Once exported, the data include only net disbursements, but not commitments. An error message is generated.

## GAVI

### Details

**Source:** GAVI Vaccine Alliance  
**Dataset:** Commitments and Dispersements for All Countries for 2001-2017 (TOTAL COMMITMENTS - Inception to June 30, 2017)  
**Brief description:** GAVI provides information regarding all of its funding commitments and dispersements for vaccine-related initiatives.   
**Level of aggregation:** Funder (always GAVI), Recipient, Program, Year  
**Location:** http://www.gavi.org/results/disbursements/  
**Data Obtained Date:** 8/8/2017  

```{r gavi_data}
## note that filepaths have to be relative to .Rmd file in order to work

## two seperate files have to be read in because they were saved as different tabs in Excel format
## will merge them later
## gavic = committed funds 
gavic <- read.table("../data/gavi/raw/gavi_commitments.tsv", 
                 stringsAsFactors = FALSE, sep = "\t", header = TRUE)

## gavid = dispersed funds
gavid <- read.table("../data/gavi/raw/gavi_disbursements.tsv", 
                 stringsAsFactors = FALSE, sep = "\t", header = TRUE)
```

### Data Processing 

* Exclude Total Counts and only look at item-level information (avoid double counting)  
* Populate empty fields caused by merges in Microsoft Excel  
* Format dollars to appear as numers (exclude commas)  
* Add "GAVI" as data source  
* Add "GAVI" as channel
* Add "Immunization" as core capability
* Add "Prevent" as core element
* Add "Public-Private partnership" as funder type

```{r, message = FALSE, warning = FALSE}
## exclude total counts
gavid <- gavid[-which(grepl("Total", gavid$Country)),]
gavic <- gavic[-which(grepl("Total", gavic$Country)),]
```

```{r}
## define function that carries down values for empty fields
## (address merged fields in excel that disappear when files read/saved as csv or tsv files)
## https://stackoverflow.com/questions/10554741/r-fill-in-data-frame-with-values-from-rows-above
filldownF <- function(x) {
  for(i in seq_along(x)[-1]) {
    if(is.na(x[i]) | x[i] == "") x[i] <- x[i-1]
  }
  x
}

## filldown to fill blanks on selected data fields
## note: eventually could modify to use apply here, but would need to deal with indexing
gavic$Country <- filldownF(gavic$Country)
gavic$Region <- filldownF(gavic$Region)
gavic$High.Level.Category <- filldownF(gavic$High.Level.Category)

gavid$Country <- filldownF(gavid$Country)
gavid$Region <- filldownF(gavid$Region)
gavid$Programme.Category <- filldownF(gavid$Programme.Category)
```

```{r, warning = FALSE}
## format numbers without commas, NA value when no data exist
## warning: NAs introduced by coercion is okay
gavic[,which(names(gavic) %in% c(paste("X", 2001:2021, sep = ""), "Grand.Total"))] <- apply(
      X = gavic[,which(names(gavic) %in% c(paste("X", 2001:2021, sep = ""), "Grand.Total"))],
      MARGIN = 2,
      FUN = function(x) {as.numeric(as.character(gsub(",", "", x)))}
)

gavid[,which(names(gavid) %in% c(paste("X", 2001:2017, sep = ""), "Grand.Total"))] <- apply(
      X = gavid[,which(names(gavid) %in% c(paste("X", 2001:2017, sep = ""), "Grand.Total"))],
      MARGIN = 2,
      FUN = function(x) {as.numeric(as.character(gsub(",", "", x)))}
)
```

```{r}
## melt data from wide to long, 
## so that there's one row per year instead of one column per year
gavic_restructured <- melt(gavic[,-which(names(gavic) == "Grand.Total")],
     id.vars = c("Country", "Region", "High.Level.Category", "Sub.category"),
     value.name = "amount_committed",
     variable.name = "year")

gavid_restructured <- melt(gavid[,-which(names(gavid) == "Grand.Total")],
     id.vars = c("Country", "Region", "Programme.Category", "Programme"),
     value.name = "amount_dispersed",
     variable.name = "year")

## remove X before year
gavic_restructured$year <- gsub("X", "", gavic_restructured$year)
gavid_restructured$year <- gsub("X", "", gavid_restructured$year)

## exclude rows with missing amount values
## (years that no funds were committed for that item, for dispersed, years that no funds were dispersed)
gavic_restructured <- gavic_restructured[-which(is.na(gavic_restructured$amount_committed) |
                                                gavic_restructured$amount_committed == 0),]
gavid_restructured <- gavid_restructured[-which(is.na(gavid_restructured$amount_dispersed) |
                                                  gavid_restructured$amount_dispersed == 0),]
```

```{r}
## join committed and dispersed datasets, which were separated because they
## were stored as separate tabs in Excel
gavi_full <- full_join(gavic_restructured, gavid_restructured,
                  by = c("Country" = "Country",
                         "Region" = "Region",
                         "High.Level.Category" = "Programme.Category",
                         "Sub.category" = "Programme",
                         "year" = "year"))
```

```{r}
gavi_full$funder <- "GAVI"
gavi_full$channel <- "GAVI"
gavi_full$data_source <- "GAVI"
gavi_full$core_capability <- "Immunization"
gavi_full$core_element <- "Prevent"
gavi_full$funder_type <- "Public-Private partnership"
```

```{r}
## reorder fields so they are sensibly ordered
gavi_full <- gavi_full[,c("Country", "Region", "High.Level.Category", "Sub.category", "core_capability",
                          "core_element", "year",  "funder", "channel", "amount_committed", "amount_dispersed",
                          "funder_type", "data_source")]
```

```{r}
## save processed data 
## save data if csv_flag is true
## don't print rownames in csv
if(csv_flag == TRUE){
  write.csv(gavi_full,
            file = "../data/gavi/processed/gavi_processed.csv", 
            row.names = FALSE)
}
```

## G-Finder

### Details

**Source:** Policy Cures G-Finder  
**Dataset:** Neglected Disease Funding for all diseases - all products for FYI 2015  
**Brief description:** The G-Finder database provides information on funding for 35 neglected diseases across 142 product areas including drugs, vaccines, diagnostics, microbicides, and vector control products. Data are collected by survey and manually collated and reviewed by the Policy Cures team.  
**Level of aggregation:** Disease, Secondary-level Disease, Product, Funder, Funding Type, Recipeint, Year  
**Location:** https://gfinder.policycuresresearch.org/PublicSearchTool/  
**Data Obtained Date:** 8/8/2017  
**Note:** It's possible to export data for long periods than just one year, but selecting especially long time periods caused the data exporter tool to return an error and no data.  

```{r gfinder_data}
## note that filepaths have to be relative to .Rmd file in order to work
gfinder <- read.csv("../data/gfinder/raw/Public Search Tool 2017-08-09.csv", 
                 stringsAsFactors = FALSE)
```

### Data Processing 

* Format dollars to appear as numers (exclude commas)  
* Remove the string "FY"" from the beginning of printed years  
* Add "G-Finder" as data source  

```{r}
## remove commas from dollar amounts
gfinder$Amount..US.. <- gsub(",", "", gfinder$Amount..US..)

## remove "FY" from the beginning of printed years
gfinder$Year.description <- as.numeric(as.character(gsub("FY ", "", gfinder$Year.description)))

gfinder$data_source <- "G-Finder"

## save processed data (that was easy!)
## save data if csv_flag is true
## don't print rownames in csv
if(csv_flag == TRUE){
  write.csv(gfinder,
            file = "../data/gfinder/processed/gfinder_processed.csv", 
            row.names = FALSE)
}
```

## IHME

### Details

**Source:** IHME (Institute for Health Metrics and Evaluation, University of Washington)  
**Dataset:** Development Assistance for Health Database 1990-2016  
**Brief description:** Information on global health assistance during the timeframe specified, based on data obtained from project databases, financial statements, annual reports, IRS 990s, and correspondence with agencies.  
**Level of aggregation:** Funder, country, geographic region, health focus area  
**Location:** http://ghdx.healthdata.org/record/development-assistance-health-database-1990-2016  
**Data Obtained Date:** 8/7/2017

```{r ihme_data}
## note that filepaths have to be relative to .Rmd file in order to work
ihme <- read.csv("../data/ihme/raw/IHME_DAH_DATABASE_1990_2016_Y2017M04D19.CSV", 
                 stringsAsFactors = FALSE)
```

### Data Processing 

* Exclude preliminary estimates and duplicated entries that could cause double-counting  
* Add "IHME" as data source  

```{r}
ihme_selected <- ihme[which(## exclude to avoid double counting
                            ihme$elim_ch >= 0 & 
                            ## exclude preliminary estimates
                            ihme$prelim_est == 0) 
                      ,]
```

*  Restructure dataset from wide to long, so that we have one row per year-funder-recipient-purpose, as opposed to the original structure of one row per year-funder-recipient with individual columns corresponding to purpose. 

```{r}
## read in file specifying fields of interest
selected_ihme_fieldnames <- read.csv("../data/ihme/relevant_fields.csv", stringsAsFactors = FALSE)

## vector of indices corresponding to the fieldnames we care about
selected_ihme_fieldnum <- which(names(ihme_selected) %in% selected_ihme_fieldnames$fieldname)

## use the fields that we specified above,
## plus other selected fields including year (1), source (2), and channel (3),
## recipient_country (5)
## then melt the data from wide to long, such that there is one row per
## year-funder-recipient-purpose
ihme_restructured <- melt(ihme_selected[,c(1,2,3,5, selected_ihme_fieldnum)],
     id.vars = c("year", "source", "channel", "recipient_country"),
     value.name = "amount",
     variable.name = "intial_variable_name_ihme")

## exclude rows corresponding to no funding (amount = 0)
## do this only if at least one row has amount = 0
if(any(ihme_restructured$amount == 0)){
  ihme_restructured <- ihme_restructured[-which(ihme_restructured$amount == 0),]
}

## merge this restructured data with data mapping "purpose" field (initial colnames of the dataset)
## to relevant descriptive data based on information provided in the IHME codebook
ihme_restructured_full <- merge(ihme_restructured, selected_ihme_fieldnames,
                                by.x = "intial_variable_name_ihme", by.y = "fieldname",
                                all.x = TRUE)

## add field indicating that these data came from IHME
ihme_restructured_full <- cbind.data.frame(ihme_restructured_full, 
                                           data_source = "IHME")

## reorder fields so that dataframe is shown in a logical order from "left" to "right"
ihme_restructured_full <- ihme_restructured_full[,c(2,3,5,4,6,7,8,9,1)]
```

```{r}
## save data if csv_flag is true
## don't print rownames in csv
if(csv_flag == TRUE){
  write.csv(ihme_restructured_full,
            file = "../data/ihme/processed/ihme_processed_channel_wide.csv", 
            row.names = FALSE)
}
```

## OIE

### Details

**Source:** OIE (World Organization for Animal Health)  
**Dataset:** OIE Procurement Contracts, Grants and Sub-Grants awarded by the OIE with funding by the European Union (EU)  
**Brief description:** All active contribution agreements signed between the OIE and the EU in support of OIE programs, project, and activities. EU Only.  
**Level of aggregation:** Funder (always EU), Recipient, Program, Year  
**Location:** http://www.oie.int/fileadmin/Home/eng/Support_to_OIE_Members/pdf/EU_Procurement-contracts-and-Grants-published_SEP-2016_01.pdf  
**Data Obtained Date:** 8/8/2017  
**Note:** Data manually extracted from pdf 

```{r oie_data}
## note that filepaths have to be relative to .Rmd file in order to work
oie <- read.table("../data/oie/raw/eu_contracts.csv", 
                 stringsAsFactors = FALSE, sep = ",", header = TRUE)
```

### Data Processing

* Extract year from field Date.of.Signature.of.Contract
* Add "OIE" as channel
* Add "OIE" as data source  

```{r}
## format field date of signature as a date
oie$Date.of.Signature.of.Contract <- as.Date(oie$Date.of.Signature.of.Contract, format = "%d/%m/%Y")

## extract year of date of contract signature
oie$Year.of.Signature.of.Contract <- as.numeric(as.character(format(oie$Date.of.Signature.of.Contract, format = "%Y")))

oie$channel <- "OIE"
oie$data_source = "OIE"
```

```{r}
## save data if csv_flag is true
## don't print rownames in csv
if(csv_flag == TRUE){
  write.csv(oie,
            file = "../data/oie/processed/oie_processed.csv", 
            row.names = FALSE)
}
```

## Aggregate Data

### Map Equivalent Fields Together  

Since each dataset (GAVI, G-Finder, OIE, and IHME) each had unique data structures and variable ("field") names, it was necessary to develop a mapping of equivalent fields. The datatable printed below shows the way in which fields in each datasource were mapped to a standardized data ontology including broad categories like year, amount, funder, and disease.  

Across sources, data are reported at varying levels of resolution. For instance, G-Finder reports disease information at a much higher level of resolution (e.g. "Strongyloidiasis & other intestinal roundworms") than IHME (e.g. "infectious disease"). 

```{r}
field_mapping <- read.table("../data/field_mapping.tsv", stringsAsFactors = FALSE, 
                            sep = "\t", header = TRUE)
```

```{r}
## exclude notes section for now
datatable(field_mapping[,-which(names(field_mapping) %in% c("notes", "subdirectory", "filename")),],
          rownames = FALSE)
```

```{r}
## GAVI data
## okay here that warnings are turned off, flag is about factors and characters being converted

## generate dataset that includes the core data elements included in GAVI,
## as specified in the field_mapping guide printed above
gavi_core_data <- gavi_full[which(names(gavi_full) %in% field_mapping$fieldname[
                                which(field_mapping$source == "GAVI" &
                                      complete.cases(field_mapping$standard_fieldname))])]

## rename core data elements of GAVI

## first create temporary dataframe that merges names of core data to standard_fieldnames specified in field_mapping guide
temp_names <- suppressWarnings(inner_join(data.frame(fieldname = names(gavi_core_data)), 
                   field_mapping[which(field_mapping$source == "GAVI"),],
                   by = "fieldname"))

## then update gavi_core_data fieldnames
names(gavi_core_data) <- temp_names$standard_fieldname; rm(temp_names)
```

```{r}
## G-FINDER DATA
## okay here that warnings are turned off, flag is about factors and characters being converted

## generate dataset that includes the core data elements included in G-Finder,
## as specified in the field_mapping guide printed above
gfinder_core_data <- gfinder[which(names(gfinder) %in% field_mapping$fieldname[
                                which(field_mapping$source == "G-Finder" &
                                      complete.cases(field_mapping$standard_fieldname))])]

## rename core data elements of G-Finder

## first create temporary dataframe that merges names of core data to standard_fieldnames specified in field_mapping guide
temp_names <- suppressWarnings(inner_join(data.frame(fieldname = names(gfinder_core_data)), 
                   field_mapping[which(field_mapping$source == "G-Finder"),],
                   by = "fieldname"))

## then update gfinder_core_data fieldnames
names(gfinder_core_data) <- temp_names$standard_fieldname; rm(temp_names)
```

```{r}
## IHME DATA
## okay here that warnings are turned off, flag is about factors and characters being converted

## generate dataset that includes the core data elements included in IHME DATA,
## as specified in the field_mapping guide printed above
ihme_core_data <- ihme_restructured_full[which(names(ihme_restructured_full) %in% field_mapping$fieldname[
                                which(field_mapping$source == "IHME" &
                                      complete.cases(field_mapping$standard_fieldname))])]

## rename core data elements of IHME data

## first create temporary dataframe that merges names of core data to standard_fieldnames specified in field_mapping guide
temp_names <- suppressWarnings(inner_join(data.frame(fieldname = names(ihme_core_data)), 
                   field_mapping[which(field_mapping$source == "IHME"),],
                   by = "fieldname"))

## then update ihme_core_data fieldnames
names(ihme_core_data) <- temp_names$standard_fieldname; rm(temp_names)
```

```{r}
## OIE DATA
## okay here that warnings are turned off, flag is about factors and characters being converted

## generate dataset that includes the core data elements included in OIE data,
## as specified in the field_mapping guide printed above
oie_core_data <- oie[which(names(oie) %in% field_mapping$fieldname[
                          which(field_mapping$source == "OIE" &
                                complete.cases(field_mapping$standard_fieldname))])]

## rename core data elements of OIE data

## first create temporary dataframe that merges names of core data to standard_fieldnames specified in field_mapping guide
temp_names <- suppressWarnings(inner_join(data.frame(fieldname = names(oie_core_data)), 
                   field_mapping[which(field_mapping$source == "OIE"),],
                   by = "fieldname"))

## then update oie_core_data fieldnames
names(oie_core_data) <- temp_names$standard_fieldname; rm(temp_names)
```


```{r}
## UNION ALL (rbind) data together for OIE, IHME, and G-Finder, plus match fieldnames
core_data <- plyr::rbind.fill(gavi_core_data,
                              gfinder_core_data,
                              ihme_core_data,
                              oie_core_data)

## recorder fields so that they seem somewhat sensible when we save/print them
core_data <- core_data[,c("project_name", "application_area", 
             "core_element", "core_capability",
             "funder", "funder_type", "funder_country",
             "channel", 
             "recipient", "recipient_type", "recipient_country",
             "amount_committed", "amount_dispersed",
             "year",
             "data_source",
             "core_capability_notes", "application_area_notes")]
```

```{r}
## assign unique ID to each row
core_data$row_id <- 1:nrow(core_data)
```

```{r}
## save data if csv_flag is true
## don't print rownames in csv
if(csv_flag == TRUE){
  
  ## save full dataset
  write.csv(core_data,
            file = "../data/aggregate/mock_ghsa_data_full.csv", 
            row.names = FALSE)
  
}

## numbers as numbers
core_data$amount_dispersed <- as.numeric(core_data$amount_dispersed)
```

#### Recipient

```{r}
## if recipient country is specified, but not recipient, use recipient country as the value for recipient
core_data[which(is.na(core_data$recipient)),]$recipient <-
  core_data[which(is.na(core_data$recipient)),]$recipient_country
```

#### Recipient Categories

```{r}
## note GAVI donation to "CAR" is for Central African Republic
## All GAVI donations are reported as being to countries
core_data[which(core_data$data_source == "GAVI"),]$recipient_type <- "Public sector"

core_data[which(core_data$recipient_type %in%
  c("Academic and other research institutions",
    "Government research institutions"
    )),]$recipient_type <- "Academic and other research institutions"

core_data[which(core_data$recipient_type %in%
  c("Aggregate Pharmaceutical and Biotechnology Companies"
    )),]$recipient_type <- "Private sector"

core_data[which(core_data$recipient_type %in%
  c("Public sector government"
    )),]$recipient_type <- "Public sector"

core_data[which(core_data$recipient_type %in%
  c("Product Development Partnership (PDP)"
    )),]$recipient_type <- "Public-Private partnership"

core_data[which(core_data$recipient_type %in%
  c("Other intermediary",
    "Private sector philanthropic foundations, trusts, NGOs, corporate donors"
    )),]$recipient_type <- "Other"

core_data[which(core_data$recipient_type %in%
  c("N/A"
    )),]$recipient_type <- "unspecified"

```

#### Funder Country

```{r}
## todo: deal with accents, for some reason UTF-8 isn't helping here
ac_map <- read.table("../data/agency_country_mapping.tsv", header = TRUE, sep = "\t",
                     stringsAsFactors = FALSE, encoding = "UTF-8")

for(i in 1:nrow(ac_map)){
  ## recode countries for recipient-country pairs
  ## wrapping with isTRUE to deal with NA values returned by any() for accents (see todo above)
  if(isTRUE(any(core_data$recipient == ac_map$agency[i]))){
    core_data[which(core_data$recipient == ac_map$agency[i]),]$recipient_country <- ac_map$agency_country[i]
  }
    ## recode countries for funder-country pairs
  ## wrapping with isTRUE to deal with NA values returned by any() for accents (see todo above)
  if(isTRUE(any(core_data$funder == ac_map$agency[i]))){
    core_data[which(core_data$funder == ac_map$agency[i]),]$funder_country <- ac_map$agency_country[i]
  }
}
```

```{r}
## print info for full datset 
paste("Full dataset has", 
      prettyNum(nrow(core_data), big.mark = ","), "rows and is", 
      file.size("../data/aggregate/mock_ghsa_data_full.csv")/1000000,
      "MB")
```

# Demo Data 

## Sampled Actual Data

The sampled dataset used as part of the demo dataset will include data from the following sources:  
  * GAVI (random sample of 25 recipient-application pairs form years 2012-2015)
  * OIE (all data from 2012-2015)
  * G-Finder (random sample of 100 data committed funds from 2015 only)

```{r}
set.seed(1202)
## store the indices of the GAVI data elements we want to include, in case we want to reference them later
gavi_sample_indices <- sample(which(core_data$year %in% c(2012:2015) &
                                    core_data$data_source == "GAVI"), size = 25)

## store the indices of the OIE data elements we want to include, in case we want to reference them later
oie_sample_indices <- which(core_data$year %in% c(2012:2015) &
                            core_data$data_source == "OIE")

set.seed(1202)
## store the indices of the OIE data elements we want to include, in case we want to reference them later
gfinder_sample_indices <- sample(which(core_data$data_source == "G-Finder"), size = 100)

## demo data combining selected data elements, identified in the notes above
demo_data_actual <- plyr::rbind.fill(core_data[gavi_sample_indices,],
                                     core_data[gfinder_sample_indices,],
                                     core_data[oie_sample_indices,])

## recode numbers as numbers
demo_data_actual$amount_dispersed <- as.numeric(demo_data_actual$amount_dispersed)
demo_data_actual$amount_committed <- as.numeric(demo_data_actual$amount_committed)
```

### Manual Recoding

#### Application Area/Disease

(Semi)-manually map application area notes to application areas. Note that we may want to update these application areas in the future.

```{r}
## where can we directly port over from application area notes to application area?
temp <- which(demo_data_actual$application_area_notes %in%
                c("HIV/AIDS",
                  "Malaria",
                  "Tuberculosis",
                  "Measles and/or Rubella"))

demo_data_actual[temp,]$application_area <- demo_data_actual[temp,]$application_area_notes
rm(temp)
  
demo_data_actual[which(demo_data_actual$application_area_notes %in%
  c("Can not be allocated to one disease Core funding of a multi-disease R&D organisation",
    "Can not be allocated to one disease General diagnostic platforms",
    "Can not be allocated to one disease Other R&D",
    "Vaccine Introduction Grant",
    "HSS", ## health system support
    "IPV", ## polio
    "ISS" ## immunization support services
    )),]$application_area <- "nonspecific"

demo_data_actual[which(demo_data_actual$application_area_notes %in%
  c("Dengue",
    "Diarrhoeal diseases",
    "Filoviral diseases (including Ebola, Marburg)",
    "HPV Demo", "HPV Demo - cash support",
    "Kinetoplastids", ## todo: check that these are infectious, they're protozoa
    "Leprosy",
    "Measles", "Measles SIA", "Measles-Rubella",
    "Meningitis A - campaign", "Meningitis A - operational costs",
    "Penta", ## pentavalent vaccine
    "Pneumo",
    "Rotavirus",
    "Salmonella infections", ## todo: check that this should be infectious
    "Yellow Fever"
    )),]$application_area <- "Infectious disease, other"

demo_data_actual[which(demo_data_actual$application_area_notes %in%
  c("Helminths (Worms & Flukes)")),]$application_area <- "Other"

## code any remaining NAs as "unspecified", only do this if NAs exist
if(any(is.na(demo_data_actual$application_area))){
  demo_data_actual[which(is.na(demo_data_actual$application_area)),]$application_area <- "unspecified"
}
```

#### Recipient

Only a single recipient example needs to be recoded.

```{r}
## todo: when figure out how to deal with UTF-8 characters, this step won't be necessary
## as it can be done in the agency_country mapping step
demo_data_actual[which(demo_data_actual$recipient == "Fondation Mérieux"),]$recipient_country <- "France"
```


#### Core Element and Core Capacity

(Semi)-manually map notes captured from various data sources to JEE core elements and core capacities. 

```{r}
## Unspecified: Unspecified
demo_data_actual[which(demo_data_actual$core_capability_notes %in%
  c("Unspecified", "")),]$core_element <- "unspecified"
demo_data_actual[which(demo_data_actual$core_capability_notes %in%
  c("Unspecified", "")),]$core_capability <- "unspecified"

## Nonspecific: Nonspecific
demo_data_actual[which(demo_data_actual$core_capability_notes %in%
  c("Basic research")),]$core_element <- "nonspecific"
demo_data_actual[which(demo_data_actual$core_capability_notes %in%
  c("Basic research")),]$core_capability <- "nonspecific"

## Prevent: Non-Specific
demo_data_actual[which(demo_data_actual$core_capability_notes %in%
  c("Microbicides", "Vector Control Products Biological control products")),]$core_element <- "Prevent"
demo_data_actual[which(demo_data_actual$core_capability_notes %in%
  c("Microbicides", "Vector Control Products Biological control products")),]$core_capability <- "nonspecific"

## Prevent: Immunization
demo_data_actual[which(demo_data_actual$core_capability_notes %in%
  c("Vaccines (Preventive)")),]$core_element <- "Prevent"
demo_data_actual[which(demo_data_actual$core_capability_notes %in%
  c("Vaccines (Preventive)")),]$core_capability <- "Immunization"

## Detect: Nonspecific
demo_data_actual[which(demo_data_actual$core_capability_notes %in%
  c("Diagnostics")),]$core_element <- "Detect"
demo_data_actual[which(demo_data_actual$core_capability_notes %in%
  c("Diagnostics")),]$core_capability <- "nonspecific"

## Respond: Nonspecific
demo_data_actual[which(demo_data_actual$core_capability_notes %in%
  c("Drugs", "Vaccines (Therapeutic)")),]$core_element <- "Respond"
demo_data_actual[which(demo_data_actual$core_capability_notes %in%
  c("Drugs", "Vaccines (Therapeutic)")),]$core_capability <- "nonspecific"
```

## Simulated Data

Generate simulated dataset, drawing from actual distribution of dispersals reported in IHME, G-Finder, GAVI, and OIE databases.

```{r, eval = FALSE}
## note: not doing this every time the Rmd file is sourced, just when needed (see eval = FALSE)
## read in simulated dataset
demo_data_sim <- read.table(file = "../data/simulated_data.tsv", sep = "\t", header = TRUE)
```

```{r, eval = FALSE}
set.seed(1202)

## Adjust levels of relative funding
## sample from 19th-80th quantile
demo_data_sim$amount_committed[which(demo_data_sim$core_element == "Prevent")] <- 
  sample(core_data$amount_dispersed[
    which(core_data$amount_dispersed >= quantile(core_data$amount_dispersed, 0.1, na.rm = TRUE) &
          core_data$amount_dispersed <= quantile(core_data$amount_dispersed, 0.8, na.rm = TRUE))], 
        size = sum(demo_data_sim$core_element == "Prevent"))

demo_data_sim$amount_dispersed[which(demo_data_sim$core_element == "Prevent")] <- 
  rnorm(n = sum(demo_data_sim$core_element == "Prevent"),
        mean = 0.8, sd = 0.1) * demo_data_sim$amount_committed[which(demo_data_sim$core_element == "Prevent")]

## sample from 10th-40th quantile
demo_data_sim$amount_committed[which(demo_data_sim$core_element == "Detect")] <- 
  sample(core_data$amount_dispersed[
    which(core_data$amount_dispersed >= quantile(core_data$amount_dispersed, 0.1, na.rm = TRUE) &
          core_data$amount_dispersed <= quantile(core_data$amount_dispersed, 0.4, na.rm = TRUE))], 
        size = sum(demo_data_sim$core_element == "Detect"))

demo_data_sim$amount_dispersed[which(demo_data_sim$core_element == "Detect")] <- 
  rnorm(n = sum(demo_data_sim$core_element == "Detect"),
        mean = 0.9, sd = 0.1) * demo_data_sim$amount_committed[which(demo_data_sim$core_element == "Detect")]

## sample from 30th-80th quantile
demo_data_sim$amount_committed[which(demo_data_sim$core_element == "Respond")] <- 
  sample(core_data$amount_dispersed[
    which(core_data$amount_dispersed >= quantile(core_data$amount_dispersed, 0.3, na.rm = TRUE) &
          core_data$amount_dispersed <= quantile(core_data$amount_dispersed, 0.8, na.rm = TRUE))], 
        size = sum(demo_data_sim$core_element == "Respond"))

demo_data_sim$amount_dispersed[which(demo_data_sim$core_element == "Respond")] <- 
  rnorm(n = sum(demo_data_sim$core_element == "Respond"),
        mean = 1.1, sd = 0.2) * demo_data_sim$amount_committed[which(demo_data_sim$core_element == "Respond")]

## sample from 10th quantile - median
demo_data_sim$amount_committed[which(demo_data_sim$core_element == "Other")] <- 
  sample(core_data$amount_dispersed[
    which(core_data$amount_dispersed >= quantile(core_data$amount_dispersed, 0.1, na.rm = TRUE) &
          core_data$amount_dispersed <= quantile(core_data$amount_dispersed, 0.5, na.rm = TRUE))], 
        size = sum(demo_data_sim$core_element == "Other"))

demo_data_sim$amount_dispersed[which(demo_data_sim$core_element == "Other")] <- 
  rnorm(n = sum(demo_data_sim$core_element == "Other"),
        mean = 1, sd = 0.01) * demo_data_sim$amount_committed[which(demo_data_sim$core_element == "Other")]

## save file if csv flag is true
if(csv_flag == TRUE){
  write.table(demo_data_sim, file = "../data/simulated_data.tsv", 
              quote = FALSE, sep = '\t', col.names = TRUE, row.names = FALSE)
}
```

```{r}
## read in simulated dataset
demo_data_sim <- read.table(file = "../data/simulated_data.tsv", sep = "\t", header = TRUE)
```

## Demo Dataset

```{r}
## merge actual and notional data, excluding certainf ields from demo_data_actual (notes)
demo_data <- plyr::rbind.fill(demo_data_actual[,-which(names(demo_data_actual) %in% 
                                                               c("application_area_notes",
                                                                "core_capability_notes"))],
                              demo_data_sim)

```

```{r}
## print demo data
datatable(demo_data, 
          ## don't show rownames
          rownames = FALSE)
```

```{r}
## save demo data if csv flag is trhe
if(csv_flag == TRUE){
  write.table(demo_data, file = "../data/demo_data.tsv", 
              quote = FALSE, sep = '\t', col.names = TRUE, row.names = FALSE)
}
```

# Analysis Ideas

## Sanity Checks of Data Generation (Notional Data)

The straighforward analyses included below are inteded to confirm that the demo dataset is functioning as expected, and to brainstorm potential visualizations for future web development.

### Data Source

Check that simulated notional data isn't too far out of line, compared to actual data. Note that since simulated data is based samples from actual data, this shouldn't be the case.

```{r, warning = FALSE}
ggplot(demo_data, aes(log(amount_dispersed), fill = data_source)) +
    geom_histogram(bins = 25) +
  ylab("Number of Dispersals") +
  xlab("Log Amount Dispersed") +
  ggtitle("Disperal Amount by Data Source") +
  ## rename legend
  scale_fill_discrete(name = "Data Source")
```

### Amount Dispersed

```{r}
## todo: still needs legend
ggplot(demo_data, aes(log(amount_dispersed))) +
    geom_histogram(data = subset(demo_data, core_element == 'Prevent'), 
                   fill = "red", alpha = 0.2, bins = 25) +
    geom_histogram(data = subset(demo_data, core_element == 'Detect'), 
                   fill = "blue", alpha = 0.2, bins = 25) +
    geom_histogram(data = subset(demo_data, core_element == 'Respond'), 
                   fill = "green", alpha = 0.2, bins = 25) +
    geom_histogram(data = subset(demo_data, core_element == 'Other'), 
                   fill = "orange", alpha = 0.2, bins = 25) +
  ylab("Number of Disperals") +
  xlab("Amount Dispersed") +
  ggtitle("Disperal Amount by JEE Core Element") 
```

## Analysis Ideas

### Which core elements (prevent, detect, respond) are most funded?

```{r}
library(scales)
ggplot(demo_data, aes(x = "", y = amount_dispersed, fill = core_element)) + 
    geom_bar(width = 1, stat = "identity")
```

### How has funding for core elements changed over time?

Something like this (https://stackoverflow.com/questions/34244813/100-stacked-area-plot-in-ggplot2) if temporal data are available.

### Where are the most funds being dispersed?

World with country color proportaional to sum of amount_dispersed, grouped by recipient_country. Not going to spend time making this in R since it's a decent amount of work and will need to be re-done in js anyway.

### Who is dispersing the most funds?

World with country color proportaional to sum of amount_dispersed, grouped by funder_country. Not going to spend time making this in R since it's a decent amount of work and will need to be re-done in js anyway.



